Linux for Robotics – EF Robotics Prep (Intro)

This course is about operating and troubleshooting real robot computers. Most robot PCs run Ubuntu. ROS/ROS2 workflows assume Linux. When a robot fails, the evidence and the controls are in Linux: services, logs, permissions, processes, and networking.

What Linux is

Linux is the kernel: the core software layer that manages hardware, memory, processes, and devices. When people say “Linux” in daily work, they usually mean a Linux distribution: the Linux kernel plus system tools and a package manager. Ubuntu is a distribution that is extremely common in robotics.

Ubuntu LTS in simple terms

Ubuntu LTS means Long-Term Support. It is the stable Ubuntu line that receives security and maintenance updates for years. Robotics prefers LTS because robot systems are dependency-heavy and sensitive to change; stability beats novelty.

Why ROS/ROS2 and robots use Linux

ROS and ROS2 are Linux-first in practice: documentation, packages, build tools, and debugging workflows are designed around Ubuntu. Robot vendors ship Ubuntu-based PCs because Linux is predictable, scriptable, and easy to manage remotely via SSH. If you can use Linux, you can install dependencies, start and monitor robot services, and diagnose failures.

Package management: apt

On Ubuntu, apt is the standard way to install tools and dependencies from repositories. You typically update package lists, upgrade installed packages, then install what you need. If a robot setup guide says “install X”, apt is usually the method unless the vendor provides a custom installer.

Command help: --help and man

Most commands support “--help” for quick usage and “man” for the full manual. The man page is the authoritative reference and often includes examples. When you are stuck on a robot PC without internet, man pages still work.

Filesystem navigation mindset

Linux work is filesystem-driven. If you can confidently navigate directories, inspect files, and create workspace structure, you can do the majority of robot operations.

pwd

pwd prints the current working directory. It answers “where am I”. This matters because scripts and tools often assume you run them from a specific folder.

cd

cd changes the current directory. “cd ..” goes up one level. “cd ~” goes to your home directory. A lot of Linux mistakes are simply “you are in the wrong directory”.

ls

ls lists directory contents. “ls -la” shows details including permissions, owner, group, file sizes, timestamps, and hidden files. In robotics, “ls -la” helps spot permission issues and confirm files exist where you think they do.

mkdir

mkdir creates directories. “mkdir -p” creates parent directories and avoids errors if a folder already exists. In robotics you want a clean predictable structure like ~/robotics/scripts and ~/robotics/logs.

touch

touch creates an empty file if it doesn’t exist, or updates its timestamp if it does. It is used for quick test files, placeholder logs, or creating files before editing.

cat

cat prints file contents to the terminal. It is the simplest way to view small configs and logs. It is also used to create files using heredocs, which is useful on robot PCs when you want repeatable setup steps.

echo

echo prints text. It is used for quick messages, for writing into files using redirection, and for debugging variables in scripts.

Redirection and pipes

“>” redirects normal output into a file and overwrites it. “>>” appends normal output to a file. “|” pipes normal output into another command. These are core skills for log analysis and automation.

stderr redirection: 2>/dev/null and 2>>/dev/null

Linux separates normal output (stdout) from error output (stderr). The number “2” refers to stderr. “/dev/null” is a special sink that discards anything written to it. So “2>/dev/null” means “hide error messages”. People use it when scanning lots of files to avoid noisy “permission denied” or “file not found” warnings. “2>>/dev/null” appends errors into /dev/null, which effectively also discards them; most people just use “2>/dev/null”.

grep

grep searches text. It is how you find error lines, timeouts, and stack traces in logs and configs. If you can grep, you can turn a huge log folder into a short list of relevant lines.

head

head prints the first lines of a file. It is used to quickly confirm file format or to see headers without opening an editor.

tail

tail prints the last lines of a file. It is the fastest “what happened most recently” tool. “tail -f” follows a file as it grows and is useful during live debugging.

wc

wc counts lines, words, and bytes. “wc -l” counts lines and is commonly used after grep to count matches.

Storage and resource sanity checks

Robots fail for boring reasons like full disks and low memory. These commands let you confirm it quickly.

df

df shows disk usage by filesystem. “df -h” prints human-readable sizes. If the disk is full, services may fail, logs may stop writing, and updates may break.

du

du shows disk usage for folders and files. “du -sh” gives a summary total for a path. It is how you find where disk space is going, often large logs, bags, or crash dumps.

free

free shows memory usage. “free -h” prints human-readable sizes. Low memory can cause slowdowns, node crashes, and OOM-killer terminations.

Processes and stopping stuck programs

Robot apps and services are processes. You must be able to find them, inspect them, and stop them safely.

ps

ps lists running processes. “ps aux” is a common view. It helps you confirm whether something is running and under which user.

pgrep

pgrep finds process IDs by name. “pgrep -a name” also prints the command line. It is faster than scanning ps output manually.

kill

kill sends a signal to a PID. Use TERM first for graceful shutdown. Use KILL only if the process is stuck and ignores TERM.

pkill

pkill kills by process name. It is convenient but can kill more than you intended if names match broadly. On robots, use it carefully.

top

top is a live process viewer that shows CPU and memory usage. It helps you spot a node pegging CPU, memory leaks, or unexpected background load.

Permissions and ownership

Permission problems are constant on robot PCs: scripts won’t execute, logs aren’t readable, and devices aren’t accessible.

chmod

chmod changes permissions. The most common robotics case is making scripts executable with “chmod +x script.sh”. If a script exists but won’t run, chmod is often the fix.

chown

chown changes owner and group. It is often needed after creating or copying files with sudo, where files become owned by root and your user can no longer edit them.

Users, groups, and safe admin work

Robot computers are often shared. You create users, add them to groups, and use sudo only when needed.

sudo

sudo runs a command as admin. Use it for installs, protected logs, system config, and service control. It is powerful and should be used deliberately.

apt

apt is Ubuntu’s package manager. It installs dependencies and tools in a standard, maintainable way.

adduser

adduser creates a new user interactively. This is typical on robot PCs so operators use a non-root account.

usermod

usermod modifies a user. The common pattern is adding group memberships using “-aG”. In robotics, groups matter for hardware access, for example “dialout” for serial devices.

groups

groups shows which groups a user belongs to. It helps explain “why does this user not have access”.

Bash variables and environment variables

A bash variable exists only in the current shell session. An environment variable is exported and inherited by programs you start from that shell. Robotics tools often depend on environment variables, and services often do not load your interactive shell environment by default.

export

export sets an environment variable so child processes can see it. This is how you make workspace paths and settings available to scripts and tools.

alias

alias defines a shortcut command for convenience in your interactive shell.

which, whoami, uname again in practice

When debugging a robot PC, these three are quick sanity checks: which tells you what binary you are actually running, whoami tells you which user you are, and uname tells you what system/kernel you are on.

Editors: nano and vim

You will edit configs, scripts, and service files. Learn one editor enough to survive on a robot PC.

nano

nano is beginner-friendly. Save with Ctrl+O then Enter. Exit with Ctrl+X. Search with Ctrl+W.

vim

vim is modal. Press i to enter insert mode. Press Esc to return to normal mode. Save and quit with :wq then Enter. Quit without saving with :q! then Enter. Search with /text then Enter, and jump to the next match with n.

Networking basics for robot connectivity

Robots are networked systems. You need to confirm IP addresses, routes, and open ports to diagnose “can’t connect to robot” and “robot can’t reach sensor” issues.

ip

ip is the modern Linux networking tool. “ip a” shows interfaces and IPs. “ip route” shows routing decisions. Prefer ip over older tools.

ifconfig

ifconfig is an older tool still referenced by legacy docs. It may require installing net-tools. Know it exists, but use ip when possible.

ss

ss shows listening ports and active connections. It answers “is the service listening” and “what port is open”.

tcpdump

tcpdump captures packets to prove whether traffic exists on the wire. It requires sudo and is advanced, but it is one of the fastest ways to prove whether a network problem is real. The correct tool name is tcpdump.

Logs and services: core robot operations

Modern Ubuntu uses systemd for service management and logging. Most production robot applications run as systemd services, and the main logs are read with journalctl.

journalctl

journalctl reads system logs from the systemd journal. Use it to see why a service failed, what happened at boot, and which errors occurred.

systemctl

systemctl controls services: show status, start, stop, restart, and enable autostart at boot. If a robot app should run automatically, systemctl is how you manage it.

Finding files when you don’t know where they are

find is the reliable way to locate files by name or type when you don’t know where they live.

find

find searches directories based on rules like name and file type. It is useful for locating logs, configs, and artifacts quickly.

tree for structure visualization

tree prints a directory as a tree and helps validate workspace structure. It may need to be installed, but it’s helpful for teaching and quick verification.

Shebang and script creation via cat

A bash script is a text file. The shebang line tells Linux which interpreter runs it. “#!/usr/bin/env bash” is a robust choice because it finds bash via the environment. You can generate scripts reliably using cat with a heredoc, which is useful on robot PCs. The accompanying commands script includes a complete example that demonstrates variables, if statements, loops, logging, and safe error handling.

End of intro.

